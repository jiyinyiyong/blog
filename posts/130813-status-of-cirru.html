<title>130813-status-of-cirru.md</title><meta charset='utf-8'><link rel='stylesheet' href='../src/page.css' /><link rel='stylesheet'  href='http://softwaremaniacs.org/media/soft/highlight/styles/github.css'><div class='home'><a href='../index.html '>Home</a></div><div class='article'><h2>Cirru, 自己学写解释器</h2>
<p>自己创造一门编程语言是理解编程语言原理很不错的一个方案<br>而且当我反感了大多数语言中充斥着括号时, 自己就很想尝试做一个<br>我还没有学编译原理, 所以这里参考的都是网上比较粗浅的资料<br>另外还有一些 Compile to JS 的语言, 尝试看了点源码, 尽管看懂挺少</p>
<p>最早把编程语言原理呈现在我面前的是 <a href="http://norvig.com/">Peter Norvig</a> 的 <a href="http://www.googies.info/articles/lispy.html">Lispy</a><br>那是一个用 Python 写的 Lisp 语法解释器, 把编程语言基本的原理揭示出来了<br>后来他还有增强版的 <a href="http://norvig.com/lispy2.html">Lispy</a>, 可惜主要的部分我没有看懂<br>好在从这里, 基本的编程语言如何运行的概念已经清晰了, 就有了一个开始<br>那时我学着用 CoffeeScript 写了一遍, 可惜现在忘了存哪儿..</p>
<p>后来有尝试去学 <a href="http://pegjs.majda.cz/">PEG.js</a> 来生成语法树, 当时在缩进方面卡住了<br>我之前尝试写 Cirru 时用的还是 Lispy 的办法解析嵌套的括号<br>到看了 <a href="https://github.com/santoshrajan/lispyscript/">Lispyscript</a> 以后会了点基础的 token 解析<br>但解析缩进语法我还是想不出来, Cirru 的计划就直接搁起来了</p>
<p>因为对编程语言的疑问, 所以我一直在关注着相关的教程看进展<br>以及我后来<a href="https://github.com/coffee-js/languages/wiki/简化的解释器入门和编程语言了解">收集的编程语言资源</a>, 也是在中间积累起来的<br>还有<a href="http://www.yinwang.org/blog-cn/2012/08/01/interpreter/">王垠也写了关于解释器的教程</a>, 只是那是 Racket 不是基本的编程语言<br>而语法是我学编程语言纠结的第一道坎, 我很想从语法开始解决</p>
<h2>重写 Cirru parser</h2>
<p>是在看到 <a href="http://maryrosecook.com/post/little-lisp-interpreter">Little Lisp interpreter</a> 文章以后重新想起这回事的<br>再后来突然想到其实 token 解析的中间状态其实可以更高效保存的, 比如:</p>
<pre><code><span class="built_in">print</span> <span class="string">"string #{print "</span><span class="built_in">string</span><span class="string">"}"</span></code></pre>
<p>这样的代码原先我只会通过一个变量保存当前状态, <code>&quot;&quot;</code> 内如何如何<br>那么内部的一个 <code>&quot;string&quot;</code> 结束后遇到括号都不知道在什么状态了<br>这种情况下其实用一个先入后出的栈来解决, 而状态就是堆叠的<br>基于这样的理解, 我计划重写 <a href="https://github.com/jiyinyiyong/cirru-parser"><code>cirru-parser</code></a> 这个模块<br>同时为了方便写判断条件, 我想实现了一个模式匹配的模块 <a href="https://github.com/jiyinyiyong/coffee-pattern#usage">coffee-pattern</a></p>
<pre><code class="lang-coffee">{match} = require<span class="string"> 'coffee-pattern'</span>

<span class="title">match</span><span class="string"> 'string or number here'</span>,<span class="string">
  'string'</span>,<span class="string"> 'string'</span>
  /^head/, (<span class="typedef"><span class="keyword">data</span>) -&gt; print "#<span class="container">{<span class="title">data</span>}</span> matches head"</span>
  /tail$/, (<span class="typedef"><span class="keyword">data</span>) -&gt; print "#<span class="container">{<span class="title">data</span>}</span> matches tail"</span>
  /fine/,<span class="string"> 'fine'</span>
  <span class="number">5</span>, (<span class="typedef"><span class="keyword">data</span>) -&gt; print 'it is five'</span>
  null, -&gt; print<span class="string"> 'matches null not undefined'</span>
  undefined, (<span class="typedef"><span class="keyword">data</span>) -&gt; print "#<span class="container">{<span class="title">data</span>}</span> has no matching pattern"</span>
  key: -&gt;<span class="string"> 'object as a shortcut'</span></code></pre>
<p>主要提供了对应 CoffeeScript 里 <code>switch/when/else</code> 的功能<br>另外额外支持了一些语法糖和正则等复杂的方案备用</p>
<h2>Cirru 语法</h2>
<p>Cirru 解释器支持的语法现在是这样几条:</p>
<ul>
<li>行内可以使用 <code>()</code> 进行代码的嵌套, 两格缩进产生行的嵌套</li>
<li>比如 <code>&quot;a string&quot;</code> 这样双引号包裹的 String</li>
<li><code>a $ b c</code> 里用 <code>$</code> 表示直到行尾的嵌套 <code>a (b c)</code></li>
</ul>
<p>具体例子在 <a href="https://github.com/jiyinyiyong/cirru-parser#syntax">README</a> 里给了比较详细的例子可以对照<br>以及做了, 自己觉得比较友好的错误提示, 提示到了字段上<br>解释器的作用是把字符串的文件, 转化成为可以递归处理的语法树<br>树上除了字段和嵌套结构, 还有为了打印出错信息而附加的行号和文件名的引用</p>
<p>中间 token 折叠为 AST 的步骤原先想会比较难, 做着发现有简单的方案:</p>
<pre><code class="lang-coffee">ast: proto.new
  init: -&gt;
    <span class="variable">@tree</span> = []
    <span class="variable">@entry</span> = [<span class="variable">@tree</span>]
    <span class="variable">@errors</span> = []
  <span class="keyword">push</span>: (data) -&gt;
    <span class="variable">@entry</span>[<span class="variable">@entry</span>.<span class="keyword">length</span> - <span class="number">1</span>].<span class="keyword">push</span> data
  nest: -&gt;
    new_entry = []
    <span class="variable">@entry</span>[<span class="variable">@entry</span>.<span class="keyword">length</span> - <span class="number">1</span>].<span class="keyword">push</span> new_entry
    <span class="variable">@entry</span>.<span class="keyword">push</span> new_entry
  ease: -&gt;
    <span class="variable">@entry</span>.<span class="keyword">pop</span>()
  newline: -&gt;
    <span class="variable">@ease</span>()
    <span class="variable">@nest</span>()</code></pre>
<p>Demo:</p>
<pre><code class="lang-coffee"><span class="cell">{protos}</span> = require <span class="string">'../coffee/states'</span>
ast = <span class="transposed_variable">protos.</span><span class="transposed_variable">ast.</span>new()

print = (<span class="transposed_variable">args...</span>) -&gt; <span class="transposed_variable">console.</span><span class="built_in">log</span> <span class="transposed_variable">args...</span>

print <span class="transposed_variable">ast.</span>tree

<span class="transposed_variable">ast.</span>push <span class="number">1</span>
<span class="transposed_variable">ast.</span>nest()
<span class="transposed_variable">ast.</span>push <span class="number">2</span>
<span class="transposed_variable">ast.</span>nest()
<span class="transposed_variable">ast.</span>push <span class="number">3</span>
<span class="transposed_variable">ast.</span>ease()
<span class="transposed_variable">ast.</span>push <span class="number">4</span>
<span class="transposed_variable">ast.</span>nest()
<span class="transposed_variable">ast.</span>push <span class="number">6</span>
<span class="transposed_variable">ast.</span>nest()
<span class="transposed_variable">ast.</span>push <span class="number">7</span>
<span class="transposed_variable">ast.</span>ease()
<span class="transposed_variable">ast.</span>push <span class="number">5</span>

print <span class="transposed_variable">JSON.</span>stringify <span class="transposed_variable">ast.</span>tree</code></pre>
<p>之前有看到过用 JS 的引用机制, 巧妙地保留嵌套内数组的引用, 送入 token 的<br>上边的代码里, <code>next</code> 方法就制造了对内存数组的引用<br>这样保证了顺序进入的 token 能被正确折叠为树状, 能被递归函数处理<br>代码里用了基于原型的 OOP 可能带来疑惑, 可以看 <a href="https://github.com/jiyinyiyong/proto-scope#proto-scope">proto-scope</a> 的介绍</p>
<p>现在的 Cirru Parser 模块是可以重用的, 如果认可我用缩进的方案的话<br>Cirru 现在其实没有其他语法, 很简陋, 只能作为学习用的代码<br>如果你用 CoffeeScript, 用 Cirru 意味着不用再手写一遍解释器部分<br>也期待有同学帮我改正 Cirru Parser 里一些问题来做更好</p>
<p>使用模块需要熟悉 Node, 然后安装模块到本地的项目里:</p>
<pre><code><span class="comment">npm</span> <span class="comment">install</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">save</span> <span class="comment">cirru</span>-<span class="comment">parser</code></pre>
<pre><code class="lang-coffee">{parse, <span class="built_in">error</span>} = <span class="built_in">require</span> <span class="string">'cirru-parser'</span></code></pre>
<p>模块提供了两个方法, 一个是根据文件名解析出 AST 树, 返回 AST 信息<br>另一个是根据给定的数据结构生成错误的格式化输出<br>目前这部分文档不够详细, 只能从我简单的代码和 README 里翻了</p>
<ul>
<li><code>parse &lt;filename&gt; =&gt; {ast: &lt;tree&gt;, errors: [&lt;error string&gt;]}</code></li>
</ul>
<p><code>parse</code> 接受一个文件名, 返回解析的 AST 以及语法上的错误<br>如果返回结果的 <code>.errors.length &gt; 0</code>, 说明有语法错误<br><code>.errors</code> 里是已经格式化好的错误内容的字符串, 取出后还有打印</p>
<ul>
<li><code>error text: &#39;msg&#39;, x: &lt;x&gt;, y: &lt;line&gt;, file: {path: &#39;&#39;, text: &#39;&#39;} =&gt; &lt;error string&gt;</code></li>
</ul>
<p><code>error</code> 是通过行号, 文件, 信息来生成错误提示的字符串, 再取出打印<br>错误的格式大概是这样的, 包括了需要查看的主要信息:</p>
<pre><code><span class="comment">✗</span> <span class="string">.</span><span class="comment">/test/piece</span>.<span class="comment">cr:</span> <span class="comment">6</span>
<span class="comment">"ddd</span>
   <span class="comment">^</span> <span class="comment">quote</span> <span class="comment">at</span> <span class="comment">end</code></pre>
<p>AST 中的一个 token 和 <code>error</code> 接受的参数都是同样结构的:</p>
<pre><code class="lang-coffee"><span class="attribute">text</span>: <span class="string">'token' # 在 error 里是错误信息</span>
<span class="attribute">x</span>: <span class="string">0 # 发生错误的行坐标, 从 0 开始</span>
<span class="attribute">y</span>: <span class="string">0 # 发生错误的行号, 从 0 开始</span>
<span class="attribute">file</span>: <span class="string"># 一个对象引用</span>
  <span class="attribute">path</span>: <span class="string">'./code.cr' # 源码文件相对路径</span>
  <span class="attribute">text</span>: <span class="string">'' # 文件内容</span></code></pre>
</div><div id="disqus_thread"></div>
  <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'jiyinyiyong';
      // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script');
          dsq.type = 'text/javascript';
          dsq.async = true;
          dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
          if (document.getElementsByTagName('head')[0]) {
            document.getElementsByTagName('body')[0].appendChild(dsq);
          }
      })();
  </script>
  <noscript>
    Please enable JavaScript to view the
    <a href="http://disqus.com/?ref_noscript">
      comments powered by Disqus.
    </a>
  </noscript>
  <a href="http://disqus.com" class="dsq-brlink">
    comments powered by
    <span class="logo-disqus">
      Disqus
    </span>
  </a>
</div><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-41753901-1', 'jiyinyiyong.github.io');
  ga('send', 'pageview');
</script>