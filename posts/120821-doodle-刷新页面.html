<title>doodle 命令行工具刷新页面</title><meta charset='utf-8'>  <div id='article'><a id='home' href='../index.html'>Home</a><link rel="stylesheet" href="../style.css"><pre> </pre><pre><pre class='title'>doodle 命令行工具刷新页面</pre></pre><pre> </pre><pre>调试 html 需要多次刷新页面, 自然而然想到用工具自动刷新</pre><pre>此前遇到过的方法有 <code class="inline_code">live-reload</code> 通过浏览器插件和 python 自动刷新</pre><pre><a href="https://github.com/lepture/python-livereload">github.com/lepture/python-livereload</a></pre><pre>当然, 其他环境的工具也是有的, 即便 Node 也是有的</pre><pre><a href="http://livereload.com/">livereload.com/</a></pre><pre><a href="https://github.com/josh/node-livereload">github.com/josh/node-livereload</a></pre><pre>用来 Chrome 扩展的话就不用 JS 环境里增加代码了, 相当不错</pre><pre>不过那对我而言比较复杂, 于是发贴, 最后想想自己写一遍看看</pre><pre><a href="http://cnodejs.org/topic/502f91f0f767cc9a51809334">cnodejs.org/topic/502f91f0f767cc9a51809334</a></pre><pre> </pre><pre><b>失败的 SSE 的尝试</b></pre><pre> </pre><pre>为了减少对其他模块的依赖, 我没有使用 watch 模块, 开始也不打算算 ws</pre><pre>前些天看到 SSE 可以从服务器向浏览器发送事件, 就找了 Node 的 demo</pre><pre><a href="http://www.html5rocks.com/en/tutorials/eventsource/basics/">www.html5rocks.com/en/tutorials/eventsource/basics/</a></pre><pre>关于 SSE 主要的代码是这样的, 还是很普通 http 响应结果:</pre><pre class='code_block'><pre>function sendSSE(req, res) {</pre><div class='code_block'><pre>res.writeHead(200, {</pre><div class='code_block'><pre>'Content-Type': 'text/event-stream',</pre><pre>'Cache-Control': 'no-cache',</pre><pre>'Connection': 'keep-alive'</pre></div><pre>});</pre><pre> </pre><pre>var id = (new Date()).toLocaleTimeString();</pre><pre> </pre><pre>// Sends a SSE every 5 seconds on a single connection.</pre><pre>setInterval(function() {</pre><div class='code_block'><pre>constructSSE(res, id, (new Date()).toLocaleTimeString());</pre></div><pre>}, 5000);</pre><pre> </pre><pre>constructSSE(res, id, (new Date()).toLocaleTimeString());</pre></div><pre>}</pre><pre> </pre><pre>function constructSSE(res, id, data) {</pre><div class='code_block'><pre>res.write('id: ' + id + '\n');</pre><pre>res.write("data: " + data + '\n\n');</pre></div><pre>}</pre></code></pre><pre>我调试最后注意到 <code class="inline_code">\n\n</code> 在事件的产生当中是必不可少的</pre><pre>而 <code class="inline_code">data:X\n\n</code> 则让事件的 <code class="inline_code">data</code> 属性赋值为 <code class="inline_code">X</code></pre><pre>此外, SSE 会产生其实每 2~4min 时间开发工具的网络中可以看到重新链接</pre><pre>当然这不影响功能, 后来却发现 SSE 不能跨域, 下面的报错:</pre><pre><code class="inline_code">SECURITY_ERR: DOM Exception 18</code></pre><pre>在网页的评论上也提到了, 似乎没有搜到好的办法</pre><pre>当时我实现的代码大致是这样的:</pre><pre><a href="https://github.com/jiyinyiyong/doodle/blob/dc92d7b410264591018458cb0794c86d0f618dac/src/doodle-server.coffee#L12">github.com/jiyinyiyong/doodle/blob/dc92d7b410264591018458cb0794c86d0f618dac/src/doodle-server.coffee#L12</a></pre><pre> </pre><pre>#基于 <code class="inline_code">ws</code> 的版本#</pre><pre> </pre><pre>后面就用 ws 模块重新写过了, 而且 websocket 是允许跨域的</pre><pre>不过 ws 服务端和浏览器端接口不同, 折腾了好久</pre><pre><a href="https://github.com/einaros/ws">github.com/einaros/ws</a></pre><pre><a href="http://www.tutorialspoint.com/html5/html5_websocket.htm">www.tutorialspoint.com/html5/html5_websocket.htm</a></pre><pre>最后完成的代码我放到了 github 和 npm 上, 参考:</pre><pre><a href="https://github.com/jiyinyiyong/doodle/tree/">github.com/jiyinyiyong/doodle/tree/</a></pre><pre><a href="http://www.elmerzhang.com/2011/09/nodejs-module-develop-publish/">www.elmerzhang.com/2011/09/nodejs-module-develop-publish/</a></pre><pre>这样 <code class="inline_code">doodle</code> 命令用来监视一个或多个文件或文件夹</pre><pre> </pre><pre>然后 html 当中导入一行 js 即可, 还是能接受的范围</pre><pre>或者也可以自定义刷新部分的代码, 而不用 <code class="inline_code">doodle</code> 中包含的代码</pre><pre>为跨机器使用, 浏览器端代码加了 <code class="inline_code">location.hostname</code> 来展示</pre><pre>此外考虑到脚本编译命令会带来多次连续的保存事件,</pre><pre>比如 <code class="inline_code">jade</code> 有 <code class="inline_code">.jade</code> 和 <code class="inline_code">.html</code> 两次事件, 后者可能因刷新而失效</pre><pre>那么我在发送刷新时有一个 100ms 的延迟, 暂时没有大问题</pre><pre> </pre><pre><b>目前的想法</b></pre><pre> </pre><pre>蹭办公室的电脑的话就有两台, 个人不喜欢一台电脑两个屏幕的</pre><pre>于是我在以前电脑上访问另一台 Nginx 的静态文件目录</pre><pre>用 IP 直接访问的, 那么 <code class="inline_code">location.hostname</code> 指向是正常的</pre><pre>然后就在笔记本编译 html 看另一个屏幕的刷新, 操作上是可行的</pre><pre>我也考虑过弄个经本替代 Nginx 静态目录, 获取更多自由</pre><pre>不过也需要自己写一遍, 暂时 Nginx 的功能完全足够了的</pre><pre> </pre><div id="disqus_thread"></div>
  <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'jiyinyiyong';
      // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script');
          dsq.type = 'text/javascript';
          dsq.async = true;
          dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
          if (document.getElementsByTagName('head')[0]) {
            document.getElementsByTagName('body')[0].appendChild(dsq);
          }
      })();
  </script>
  <noscript>
    Please enable JavaScript to view the
    <a href="http://disqus.com/?ref_noscript">
      comments powered by Disqus.
    </a>
  </noscript>
  <a href="http://disqus.com" class="dsq-brlink">
    comments powered by
    <span class="logo-disqus">
      Disqus
    </span>
  </a>
</div></div>