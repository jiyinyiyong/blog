
SICP Notes
------

### Chapter 0

Lisp 不如 Fortran 发明得早. Scheme 更接近 Algol 60 而不是早期的 Lisp.
Algol 60 的基因还在 Scheme 和 Pascal 里, 但两者差异极大.

人工智能邻域之外, 新的问题容易孵化新的语言, 新的语言越来越不基本.
而是逼近系统的边界, 控制和隔离作业模块之间的信息流动,
渐渐逼近与人交互最频繁的地方.
-- bash 就是这样, 终端交互的工具, 而不是一门语言, 设计目标不同
Lisp 语法简单, 无法分析没有任何价值, 减少了程序员的负担

语言不仅是计算机操作的方式, 更是方法学思想的媒介, 程序是为给人阅读

Scheme 的形式化性质一小时能讲完, 很快不用在去关心语法上的事
Scheme 从 Lisp 学会t元语言和语法, 程序与数据统一, 内存回收技术(?)
从 Algol 取了词法作用域和块结构

### Chapter 1

语言强大所需的三种机制, 基本表达式, 组合的方法, 抽象的方法
程序中过程和数据是严格分离的, 操作和被操作的不同

-- 环境说到底是变量的存储器, 也即数据的存储器
-- 存储变量的不同方式可以带来好多不同的效果, 比如数据库各种模式
-- 还有 OO 将数据绑定在数据上, 也是创造了新的手法
-- 不过我们还没创造足够灵活的语言去自由设计各种手法

-- 函数是一个子过程. 传递参数其实是在两个作用域之间传递数据
-- 而函数每次调用相当于函数内部作用域重置一次
-- 单看这点, 类的实例化类似, `new` 执行时重新给出干净的实例

组合表达式的概念极为基础, 这是递归发挥作用的地方
每个表达式都需要指明其环境

求值顺序有正则求值序和应用求值序
  define (square x) (* x x)
  square (+ 5 1)
这样的代码中, 前者执行两次 (+ 5 1) , 后者不同, 只有一次
Scheme 用的是后者, 当然为提高些效率. 避免前者可能带来的复杂

Scheme 计算阶乘的例子, 递归被改写成了可用尾递归的迭代
文中提醒要注意有些递归其实是迭代, 两者的计算过程是不同的
scm 常说有尾递归优化, 初步看就是优化尾递归为迭代, 减少内存消耗
另外第二个例子和 CPS 不同但相似, 在计算有保存计算的状态进行传递

-- `fib-iter` 函数类似写法我看别人写过, 想不到原来是这里
-- 交换参数顺序当时很纳闷, 后来明白是将数值累加到其中一个参数中
-- 这是纯函数避免状态使用的手法, scm 居然用得那么顺手..

求乘幂的算法将指数按偶数除以 2 递归, 非常振奋
