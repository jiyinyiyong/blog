<title>字符串作为要素</title><meta charset='utf-8'>  <div id='article'><a id='home' href='../index.html'>Home</a><link rel="stylesheet" href="../src/liuxian.css"><pre> </pre><pre><pre class='title'>字符串作为要素</pre></pre><pre> </pre><pre>文章立足点依然是 Peter Norvig 大神 的 Lispy, 但第二篇文章还没看</pre><pre><a href="http://norvig.com/lispy.html">norvig.com/lispy.html</a></pre><pre><a href="http://norvig.com/lispy2.html">norvig.com/lispy2.html</a></pre><pre> </pre><pre>这两天想过把变量名用字符串生成的问题, 有点收获和困惑</pre><pre>如果变量名用字符串生成, 那么后续的代码怎样访问这个字符串, 是个问题</pre><pre>一般访问变量至少需要知道变量名才行的, 换 JSON 和 Array 也类似</pre><pre>今天突然想起 MongoDB 里如果 Query, 并不是马上得到变量名才完成</pre><pre>不过单纯的运算, 把数据存到 DB 然后 Query 不会有多大的意义</pre><pre>而且存储数据到地址, 再从地址取回数据, 这都是广泛使用的</pre><pre>那么变量存储存储地址不确定, 本身就失去了意义</pre><pre>不过我假想某个问题会触及到这点, 也许会有清晰一些的想法, 存疑..</pre><pre> </pre><pre>Lispy 中解析成数组的 tree 之后, 就是每个 Array 确定一个函数了</pre><pre>但我想, 还是可以有变化的, 比如下面的过程:</pre><pre>字符串的内容是:</pre><pre class='code_block'><pre>"(f1 p1 (f2 p2 p3))"</pre></code></pre><pre>解析的结果得到一个字符串的嵌套数组:</pre><pre class='code_block'><pre>['f1', 'p1', ['f2', 'p2', 'p3']]</pre></code></pre><pre>比如字符串:</pre><pre class='code_block'><pre>"(map sum (list 1 2))"</pre><pre>"(string hello world !)"</pre></code></pre><pre>解析结果带有数字:</pre><pre class='code_block'><pre>['map', 'sum', ['list', 1, 2]]</pre><pre>['string', 'hello', 'world', '!']</pre></code></pre><pre>我的思路, 不换算数字, 另外允许字符串中存在空格和括号</pre><pre>那么字符串就要添加上记号来转移结构控制相关的符号:</pre><pre class='code_block'><pre>"(string hello\ \(good\ morning\))"</pre></code></pre><pre>解析的结果就是</pre><pre class='code_block'><pre>['string', 'hello (good morning)']</pre></code></pre><pre>具体解析的过程, 也许控制符号才需要被转义,</pre><pre>加入几个特殊符号来协助: ┗ ┛ ░  ◖ ◗ ▓ ∂</pre><pre>引号并不参与到内容的解析:</pre><pre class='code_block'><pre>S.0</pre><div class='code_block'><pre>"(string hello\ \(\\good\ morning\))"</pre></div><pre>S.1</pre><div class='code_block'><pre>"(string hello\ \(∂good\ morning\))"</pre></div><pre>S.2</pre><div class='code_block'><pre>"(string hello░┗∂good░morning┛)"</pre></div><pre>S.3</pre><div class='code_block'><pre>"◖string▓hello░┗∂good░morning┛◗"</pre></div><pre>S.4</pre><div class='code_block'><pre>"◖string▓hello (\good morning)◗"</pre></div><pre>S.5</pre><div class='code_block'><pre>['string', 'hello (\good morning)']</pre></div></code></pre><pre>这一点和后边并不相关, 只是为允许必要的括号</pre><pre>Cirru 中用图形允许字符串中的特出符号, 用文本也是可行的</pre><pre>而且, 为了能达到 Bash 那样字符串和变量混杂的效果, 要尝试</pre><pre> </pre><pre>总之, 能得到那样的一个数组, 省略符号简写是这样:</pre><pre class='code_block'><pre>f1 p1 (f2 p2 p3 p4)</pre></code></pre><pre>自然, 按 Lispy 的写法, 其中有两个函数 <code class="inline_code">f1</code> 和 <code class="inline_code">f2</code></pre><pre>我试想, 不妨用 Curry 函数, 那么可以表示为逐个接收参数:</pre><pre class='code_block'><pre>b1 = f2 ⇦  p2 ⇦  p3 ⇦  p4</pre><pre>f1 ⇦  p1 ⇦  b1</pre></code></pre><pre><code class="inline_code">f1</code> 接受第一个函数返回一个接收下一个参数</pre><pre>虽然我打算未来尝试限定参数的类型, 但对数组作为源码要比较特殊</pre><pre>打算把数组后边的部分作为参数整体传递, 还是看例子:</pre><pre class='code_block'><pre>S.0</pre><div class='code_block'><pre>f1 p1 p2 f2 p3</pre></div><pre>S.2</pre><div class='code_block'><pre>r1 = f1 ⇦  (p1 p2 f2 p3)</pre><pre>r1 = f1 ⇦  p1</pre><pre>;; 这时 f1 可以选择只接受头部的 p1 作为参数</pre></div><pre>S.3</pre><div class='code_block'><pre>r2 = r1 ⇦  p2</pre><pre>;; 这时的 r2 比方说, 返回接收全部参数的参数</pre></div><pre>S.4</pre><div class='code_block'><pre>r3 = f2 ⇦  p3</pre><pre>r4 = r2 ⇦  r3</pre></div></code></pre><pre>这样当遇到类似 Bash 命令的, 就可以先将后边执行:</pre><pre class='code_block'><pre>set x number 3</pre><pre>⇒  set x 3</pre><pre>⇒  3</pre></code></pre><pre> </pre><pre>然后在 Curry 的过程中是否能添加作用域的改变呢</pre><pre class='code_block'><pre>f1 p1 p2 p3</pre><pre>r1 = f1 ⇦  p1</pre><pre>;; 向作用域绑定变量</pre><pre>r2 = r1 ⇦  p2</pre><pre>;; 向作用域绑定变量</pre><pre>r3 = r2 ⇦  p3</pre></code></pre><pre> </pre><div id="disqus_thread"></div>
  <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'jiyinyiyong';
      // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script');
          dsq.type = 'text/javascript';
          dsq.async = true;
          dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
          if (document.getElementsByTagName('head')[0]) {
            document.getElementsByTagName('body')[0].appendChild(dsq);
          }
      })();
  </script>
  <noscript>
    Please enable JavaScript to view the
    <a href="http://disqus.com/?ref_noscript">
      comments powered by Disqus.
    </a>
  </noscript>
  <a href="http://disqus.com" class="dsq-brlink">
    comments powered by
    <span class="logo-disqus">
      Disqus
    </span>
  </a>
</div></div>