
## 重构 Cirru, 增加 watch 函数

之前在 [languages 上发了一篇关于 Live Coding 的想法][live]
于是努力尝试将其做出来, 调了三天多, 只能出运行 fibonacci 的版本
断网所以没能往 Github 上 push, 而我现在也不想继续在上边多花精力
我趁现在把代码中碰到的问题仔细描述一遍, 希望以后有用

[live]: https://github.com/coffee-js/languages/issues/30

### 部分重载模块

帖子里提到我想象未来环境能检测代码修改, 部分重载对应内存
我细想精确到内存恐怕不成, 而精确到文件却是可以的
看 Lua 不成, 我于是用 Node 继续做 Demo, 并且 watch 每个加载的文件

最终的方案是在环境全局定义 `al_libs` 对象存放所有内容
具体说是运行之后的整个 `scope` Object, 并用绝对文件名做索引
当文件检测到有刷新时刷新 `scope` 的数据, 另外有通知其他文件
循环依赖问题因为可以检测全局变量查看是否已经加载, 不成问题
引入的问题是模块的参数可能被其他代码改变而没有俺需要快速刷新

每个文件在初始化时有一个 Object 存储父文件和 AST 等信息
文件的更新随着父文件的树向上传递, 主要是 `require` 函数
AST 的缓存可以避免传递时重新解析未改变的文件内容

#### 面向对象的思想

从前我理解消息机制更觉得是拷贝信息字符串然后发送到对方
而 JS 中看到的是暴露整个对象, 允许其他代码通过对象引用
从这个思路, 闭包的确能实现消息, 除了灵活和代码的混乱
我能接受这是构建大型软件的必经之路, 但恐怕无法就此领会

回想起来, 看到过说 MVC 需要有全局变量作为协调, 我用到了
说起来我挺喜欢用函数式的代码创造一个个新的作用域的
也许这可以用在未来写分形, 以此作为消息传递的天然途径

### 混用数据和符号

Lisp 中有几倍于 JS 种类型, 特别是 Symbol, 让我好奇变量的类型
JS 中变量是一个作用域里的一个键, 几乎是字符串
在之前学解释器时弄明白也都是字符串解析到字符串对应的值
中间遇到一个问题是 AST 中的数据类型和 Cirru 中的类型难以判断
大概好的实现会增加一层隔离, 而我期待这种融合能带来有趣

同时我也将执行表的 `read` 函数暴露给 Cirru 使用
Lisp 中数据和代码一定程度上能进行转换, 而且好多动态语言也是
代码中的传值通常是引用或者具体的值. 而解释器中常有是作用域
也许 Cirru 中传递变量名和作用域也能结合进来, 导致一些新功能
我承认这会在开发中带来一些混乱, 但一方面也是在简化体系

向之前我所期待的, 能像 Lua 用 `setenv with` 操作作用域
并将作用域简化成一个 Object 数据类型, 而这样便于模拟对象
而 Cirru 最后简化到字符串, 数字, 表, 函数这样几个概念
此外头部的函数, 我规定当头部是 Object 是作为表展开, 后边会讲

另外在 Bash 优秀之处也在与字符串和变量之间方便
我想 Cirru 应该同时保证严谨和 DSL 的简短, 被交互式使用
REPL 我不想做, 我希望以部分刷新来代替 REPL 的使用

### 核心和模块

现在 Cirru `index.coffee` 中内容相当少, 内置的函数仅仅几个
比如 `require echo read filename` 我是作为内置的函数
其他函数用 `init` 引入, 并且改写作用域, 就像本地的函数一样使用
或者, 其他人的确可以自己 Folk 一个版本实现自己的函数集
核心的功能仅仅是模块管理和语法的限定, 在函数名之类方面不做实现

希望 Cirru 能用本地代码的实现, 或者在某个虚拟机上实现
C 是机器码绕不过的, 可我觉得我没希望了, 转向各种 VM
Node 上做 Demo 最多了. 未来也许尝试 Parrot VM 上对付一下
而模块想象着未来作为一门语言, 每个位置有不同的实现和词汇
Cirru 自己规范了这样一套语法, 目标当然是图形化那个版本

### 行号和报错

粗略部署了一些对于行号的报错提示, 实在很简陋
目前的做法是借助 JS 一切皆对象的特性在 Array 上标记行号
再是 `read` 函数上做了手脚, 捕捉报错以及找到对应行的数据

### Curry 函数的实现

我对 Cirru 的设想是这样的, 首先是上边说过的模块系统作为基础
其次语法模仿 Lisp, 但更极端地排除用符号作为语法的部分
再者, 每个表达式头部应该是 Object 或者函数, 后边是参数
Object 和函数的共同点是接受数据后能返回数据
而 Curry 函数接收参数部分执行函数的方式和 Object 接收字符串非常相似
同时 Haskell 中规定特例的方式, 正像 Object 与函数的结合
这一点我没能实现, 希望未来有机会在 Cirru 中实现

以往解释器生成函数的方式是返回一个函数,其中创建新的作用域
接着将参数在其中对应赋值, 再以此为作用域执行规定的代码
这次新的问题是接受函数的方式是 Curried, 需要用递归
我加上看电影花了一天多终于调试完成这样一个 fibonacci 函数
需要特别注意引用正确的作用域, 并在每次接收参数时生成作用域
下面匿名函数的例子里涉及到了 3 个作用域的数据传递:

```coffeescript
fn = (item1, scope) -> (item2) ->
  if item1[0]?
    do ret = (scope, item1) ->
      (arg, out_scope) ->
        child = spawn scope
        value = get arg, out_scope
        key = item1[0]
        child[key] = value
        if item1[1]? then ret child, item1[1..]
        else get item2, child
  else
    child = spawn scope
    get item2, child
```

生成 Curry 的表达式的一个思路是"返回接受参数的函数"
但一个问题是我们期待最终返回的是函数返回值而不是函数
匿名函数的方案是判断参数剩余数量, 最终返回函数的执行
可有时可能无法决定, 目前 `do` 函数就简单地没有使用返回值
可想这给函数的编制带来了难度, 到处是函数的嵌套
至此我有了一些研究数学的感觉, 大概这个方向是对的

### 闭包的神奇

除了对象机制, 闭包给数据的相互引用代码了极大的方便
特别是函数进行递归时生成一层层的作用域带来需要奇妙的手法
而不借助闭包和递归, 这将难以实现, 比如作用域的层叠
Parrot VM 中我想尝试下实现闭包的功能, 那会非常有趣
堆栈模型和寄存器模型是我关心的问题, 以后期待深入
