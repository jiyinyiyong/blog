<div id='article'><title>Cirru 编辑器重写的感受</title><a id='home' href='../index.html'>Home</a><link rel="stylesheet" href="../style.css"><p>&nbsp;</p><p><p class='title'>Cirru 编辑器重写的感受</p></p><p>&nbsp;</p><p>回到家这几天, 大学好绝望, 而且从没能很专心学东西过, 所以代码很慢</p><p>只是写了下, 感受良多. 而且边写边搜 jQuery 的 API 感觉不错</p><p>之前 fork nodeclub 的界面时被其中几行 jQuery 打动了</p><p>比如用 <code class="inline_code">.parent()</code> 用 <code class="inline_code">.find()</code> 在 DOM 里徘徊都是之前我没接触过的</p><p><a href="https://github.com/jiyinyiyong/nodeclub/blob/master/views/topic/index.html#L195">github.com/jiyinyiyong/nodeclub/blob/master/views/topic/index.html#L195</a></p><p>&nbsp;</p><div class='code_block'><p class='code_line'>var&nbsp;editor&nbsp;=&nbsp;$btn.parents('.reply2_area').find('.reply2_editor');</p><p class='code_line'>editor.show('fast');</p><p class='code_line'>editor.find('textarea').focus();</p><p class='code_line'>var&nbsp;user&nbsp;=&nbsp;$btn.parents('.reply2_item').find('.reply_author').find('a').html();</p><p class='code_line'>var&nbsp;textarea&nbsp;=&nbsp;editor.find('textarea');</p></code></div><p>&nbsp;</p><p>我所有的知识来源无非论坛, 新闻和搜索, 遇事也只好自己对付</p><p>那么摸索了最后自己能抱一个什么样的目标呢? 我一再一再惶惑</p><p>Cirru 是插曲, 本想设计很先进的聊天室等人去实现的, 可聊天室没动静</p><p>Cirru 只想未来能成就语言, 算我在赌一个未来, 人们接受自动管理括号么?</p><p>上一次尝试, 两个月前, 做得比较多, 详细的想法当时有记录:</p><p><a href="https://github.com/jiyinyiyong/code_blocks/blob/gh-pages/about.md">github.com/jiyinyiyong/code_blocks/blob/gh-pages/about.md</a></p><p>&nbsp;</p><p>关于代码, 主要是设置当前元素 <code class="inline_code">contenteditable = true</code> 来提供编辑能力</p><p>然后用 jQUery 不断调换 <code class="inline_code">editable</code> 绑定元素, 比如在响应事件时</p><p>嵌套关系映射在这里其实是 DOM 里的嵌套, 最后的 <code class="inline_code">parse()</code> 也是这么想的</p><p>&nbsp;</p><div class='code_block'><p class='code_line'>$&nbsp;-&gt;</p><div class='code_block'><p class='code_line'>editable&nbsp;=&nbsp;'contenteditable'</p><p class='code_line'>caret&nbsp;=&nbsp;"&ltcode&nbsp;id='target'&nbsp;#{editable}='true'/&gt;"</p><p class='code_line'>blank&nbsp;=&nbsp;['',&nbsp;'&ltbr&gt;']</p><p class='code_line'>paste&nbsp;=&nbsp;''</p></div></code></div><p>&nbsp;</p><p>正在编辑的元素标记名称为 <code class="inline_code">#point</code>, 另外 <code class="inline_code">#target</code> 和上面的 <code class="inline_code">caret</code> 对应</p><p>我重写的方案是在移动 <code class="inline_code">#point</code> 时不先移动, 而是先绘制一个 <code class="inline_code">#target</code> 作为目标</p><p>再调用 <code class="inline_code">point()</code> 将完成这一步转化</p><p>&nbsp;</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;p&nbsp;=&nbsp;-&gt;&nbsp;$&nbsp;'#point'</p><div class='code_block'><p class='code_line'>t&nbsp;=&nbsp;-&gt;&nbsp;$&nbsp;'#target'</p><p class='code_line'>&nbsp;</p><p class='code_line'>empty&nbsp;=&nbsp;(elem)&nbsp;-&gt;&nbsp;elem.html()&nbsp;in&nbsp;blank</p><p class='code_line'>root&nbsp;=&nbsp;(elem)&nbsp;-&gt;&nbsp;elem.parent().attr('id')&nbsp;is&nbsp;'editor'</p><p class='code_line'>exist&nbsp;=&nbsp;(elem)&nbsp;-&gt;&nbsp;elem.length&nbsp;&gt;&nbsp;0</p><p class='code_line'>leaf&nbsp;=&nbsp;(elem)&nbsp;-&gt;&nbsp;elem[0].tagName&nbsp;is&nbsp;'CODE'</p></div></code></div><p>&nbsp;</p><p>上面四个函数用来判断节点具体的位置, 具体用到时逻辑比较繁琐</p><p><code class="inline_code">point()</code> 接收的参数只是为屏蔽 <code class="inline_code">click</code> 一次多余的 <code class="inline_code">focus()</code>, 意义不大</p><p>函数目标是将 <code class="inline_code">#point</code> 取消标记, 如果为空, 还要递归地将空元素删除</p><p>不过 <code class="inline_code">#point</code> 在 <code class="inline_code">delete</code> 时会强制删除, 因而可能元素已经不存在了</p><p>&nbsp;</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;point&nbsp;=&nbsp;(refocus&nbsp;=&nbsp;yes)&nbsp;-&gt;</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;old&nbsp;=&nbsp;p().removeAttr('id').removeAttr&nbsp;editable</p><div class='code_block'><p class='code_line'>if&nbsp;exist&nbsp;old</p><div class='code_block'><p class='code_line'>old.html&nbsp;(old.html().replace&nbsp;/\&ltbr\&gt;/g,&nbsp;'')</p><p class='code_line'>old[0].onclick&nbsp;=&nbsp;(e)&nbsp;-&gt;</p><div class='code_block'><p class='code_line'>old.attr('id',&nbsp;'target').attr(editable,&nbsp;'true')</p><p class='code_line'>point&nbsp;off</p><p class='code_line'>e.stopPropagation()</p></div><p class='code_line'>while&nbsp;empty&nbsp;old</p><div class='code_block'><p class='code_line'>up&nbsp;=&nbsp;old.parent()</p><p class='code_line'>old.remove()</p><p class='code_line'>old&nbsp;=&nbsp;up</p><p class='code_line'>if&nbsp;root&nbsp;old</p><div class='code_block'><p class='code_line'>if&nbsp;empty&nbsp;old&nbsp;then&nbsp;old.remove()</p><p class='code_line'>break</p></div></div></div><p class='code_line'>t().attr('id',&nbsp;'point').attr(editable,&nbsp;'true')</p><p class='code_line'>if&nbsp;refocus&nbsp;then&nbsp;focus()</p></div></div></code></div><p>&nbsp;</p><p>聚焦主要是处理怎样将光标放在字串结尾, 代码是搜索抄的, 不清晰</p><p>当时写着一遍测试 <code class="inline_code">collapse()</code> 不同参数的效果, 很不安全的代码</p><p>StackOverflow 的代码解释不够清晰, 没看懂只能带过了</p><p><code class="inline_code">.inline</code> 是为了将单层的括号放在行内, 本想用 css 选择器, 最后换 jQuery</p><p>&nbsp;</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;focus&nbsp;=&nbsp;-&gt;</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;sel&nbsp;=&nbsp;window.getSelection()</p><div class='code_block'><p class='code_line'>sel.collapse&nbsp;p()[0],&nbsp;1</p><p class='code_line'>$('div').addClass&nbsp;'inline'</p><p class='code_line'>$('div:has(div)').removeClass&nbsp;'inline'</p><p class='code_line'>p().focus()</p></div></div></code></div><p>&nbsp;</p><p>初始化最初的光标, 并指定 <code class="inline_code">click</code> 能将光标聚焦</p><p><code class="inline_code">in_sight</code> 是光标是否聚焦的状态, 打算包装成 lib, 可能用到</p><p>&nbsp;</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;$('#editor').append&nbsp;caret</p><div class='code_block'><p class='code_line'>t().attr&nbsp;'id',&nbsp;'point'</p><p class='code_line'>focus()</p><p class='code_line'>$('#editor')[0].onclick&nbsp;=&nbsp;(e)&nbsp;-&gt;</p><div class='code_block'><p class='code_line'>focus()</p><p class='code_line'>e.stopPropagation()</p><p class='code_line'>parse()</p></div><p class='code_line'>&nbsp;</p><p class='code_line'>in_sight&nbsp;=&nbsp;yes</p><p class='code_line'>$('#editor').bind&nbsp;'focus',&nbsp;-&gt;&nbsp;in_sight&nbsp;=&nbsp;yes</p><p class='code_line'>$('#editor').bind&nbsp;'blur',&nbsp;-&gt;&nbsp;in_sight&nbsp;=&nbsp;no</p><p class='code_line'>&nbsp;</p><p class='code_line'>$('#editor').keydown&nbsp;(e)&nbsp;-&gt;</p><div class='code_block'><p class='code_line'>#&nbsp;console.log&nbsp;e.keyCode</p><p class='code_line'>if&nbsp;in_sight</p><div class='code_block'><p class='code_line'>switch&nbsp;e.keyCode</p></div></div></div></code></div><p>&nbsp;</p><p>回车键创建嵌套, 跳出当前 <code class="inline_code">#point</code> 在后嵌入 <code class="inline_code">#target</code> 而已</p><p>Tab 就直接谁知 <code class="inline_code">#target</code> 就好了</p><p>&nbsp;</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when&nbsp;13</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p().after&nbsp;"&ltdiv&gt;#{caret}&lt/div&gt;"</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next&nbsp;=&nbsp;p().next()</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;next[0].onclick&nbsp;=&nbsp;(e)&nbsp;-&gt;</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;next.append&nbsp;caret</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;point()</p><div class='code_block'><p class='code_line'>e.stopPropagation()</p></div></div><p class='code_line'>when&nbsp;9&nbsp;then&nbsp;p().after&nbsp;caret</p></div></div></div></div></code></div><p>&nbsp;</p><p>删除时默认落到前一个字串去, 没有前就往后, 再没有就尝试删除嵌套</p><p>当然向前向后遇到嵌套的话要进入到嵌套当中去</p><p>&nbsp;</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when&nbsp;46&nbsp;#&nbsp;key&nbsp;delete</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;exist&nbsp;p().prev()</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it&nbsp;=&nbsp;p().prev()</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;leaf&nbsp;it&nbsp;then&nbsp;it.attr&nbsp;'id',&nbsp;'target'</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;it.append&nbsp;caret</p><div class='code_block'><p class='code_line'>else&nbsp;if&nbsp;exist&nbsp;p().next()</p><div class='code_block'><p class='code_line'>it&nbsp;=&nbsp;p().next()</p><p class='code_line'>if&nbsp;leaf&nbsp;it&nbsp;then&nbsp;it.attr&nbsp;'id',&nbsp;'target'</p><p class='code_line'>else&nbsp;it.prepend&nbsp;caret</p></div><p class='code_line'>else&nbsp;unless&nbsp;root&nbsp;p()</p><div class='code_block'><p class='code_line'>p().parent().after(caret).remove()</p></div><p class='code_line'>else&nbsp;unless&nbsp;p().html()&nbsp;in&nbsp;blank&nbsp;then&nbsp;p().after&nbsp;caret</p><p class='code_line'>else&nbsp;return&nbsp;on</p><p class='code_line'>p().remove()</p></div></div></div></div></div></code></div><p>&nbsp;</p><p>上下键按字串跳, 遇到嵌套也会自动进入/退出</p><p>&nbsp;</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when&nbsp;38&nbsp;#&nbsp;up</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unless&nbsp;p().html()&nbsp;in&nbsp;blank&nbsp;then&nbsp;p().before&nbsp;caret</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;exist&nbsp;p().prev()</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev&nbsp;=&nbsp;p().prev()</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;leaf&nbsp;prev&nbsp;then&nbsp;prev.attr&nbsp;'id',&nbsp;'target'</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;else&nbsp;prev.append&nbsp;caret</p><p class='code_line'>else&nbsp;unless&nbsp;root&nbsp;p()&nbsp;then&nbsp;p().parent().before&nbsp;caret</p><p class='code_line'>else&nbsp;return&nbsp;off</p></div><p class='code_line'>when&nbsp;40&nbsp;#&nbsp;down</p><div class='code_block'><p class='code_line'>unless&nbsp;p().html()&nbsp;in&nbsp;blank&nbsp;then&nbsp;p().after&nbsp;caret</p><p class='code_line'>else&nbsp;if&nbsp;exist&nbsp;p().next()</p><div class='code_block'><p class='code_line'>next&nbsp;=&nbsp;p().next()</p><p class='code_line'>if&nbsp;leaf&nbsp;next&nbsp;then&nbsp;next.attr&nbsp;'id',&nbsp;'target'</p><p class='code_line'>else&nbsp;next.prepend&nbsp;caret&nbsp;&nbsp;</p></div><p class='code_line'>else&nbsp;unless&nbsp;root&nbsp;p()&nbsp;then&nbsp;p().parent().after&nbsp;caret</p><p class='code_line'>else&nbsp;return&nbsp;off</p></div></div></div></div></div></code></div><p>&nbsp;</p><p>剪切粘贴的实现比较粗糙, 快捷键绑定在 Chrome 里没多少键可指定</p><p>幸而有 <code class="inline_code">.outerHTML</code> 这个属性, 否则实现起来更麻烦了</p><p>&nbsp;</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when&nbsp;219&nbsp;#&nbsp;ctrl&nbsp;+&nbsp;[</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;e.ctrlKey&nbsp;and&nbsp;(not&nbsp;(root&nbsp;p()))</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;up&nbsp;=&nbsp;p().parent()</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;up.after&nbsp;caret</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;&nbsp;&nbsp;point()</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;console.log&nbsp;up.parent()</p><div class='code_block'><p class='code_line'>paste&nbsp;=&nbsp;up[0].innerHTML&nbsp;or&nbsp;''</p><p class='code_line'>up.remove()</p></div><p class='code_line'>return&nbsp;on</p></div><p class='code_line'>when&nbsp;221&nbsp;#&nbsp;ctrl&nbsp;+&nbsp;]</p><div class='code_block'><p class='code_line'>if&nbsp;e.ctrlKey&nbsp;and&nbsp;paste.length&nbsp;&gt;&nbsp;0</p><div class='code_block'><p class='code_line'>p().before&nbsp;paste</p></div><p class='code_line'>return&nbsp;on</p></div><p class='code_line'>when&nbsp;33&nbsp;#&nbsp;pgup</p><div class='code_block'><p class='code_line'>unless&nbsp;root&nbsp;p()&nbsp;then&nbsp;p().parent().before&nbsp;caret</p><p class='code_line'>else&nbsp;return&nbsp;on</p></div><p class='code_line'>when&nbsp;34&nbsp;#&nbsp;pgdown</p><div class='code_block'><p class='code_line'>unless&nbsp;root&nbsp;p()&nbsp;then&nbsp;p().parent().after&nbsp;caret</p><p class='code_line'>else&nbsp;return&nbsp;on</p></div><p class='code_line'>else&nbsp;return&nbsp;on</p></div><p class='code_line'>point()</p></div><p class='code_line'>e.stopPropagation()</p><p class='code_line'>off</p></div></div></code></div><p>&nbsp;</p><p>为了阻止键盘事件副作用, 上面有比较多的 <code class="inline_code">return</code> 来处理逻辑</p><p><code class="inline_code">.stopPropagation()</code> 方法是 <code class="inline_code">click</code> 用的, 这边没必要</p><p>不过此前尝试多种尝试组织冒泡都没成功, 这个方法是很随意的了</p><p>&nbsp;</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;parse&nbsp;=&nbsp;-&gt;</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;map&nbsp;=&nbsp;(item,&nbsp;b)&nbsp;-&gt;</p><div class='code_block'><p class='code_line'>&nbsp;&nbsp;if&nbsp;leaf&nbsp;[item]&nbsp;then&nbsp;item.innerText</p><div class='code_block'><p class='code_line'>else&nbsp;[$.map&nbsp;item.children,&nbsp;(x)&nbsp;-&gt;&nbsp;map&nbsp;x]</p></div><p class='code_line'>res&nbsp;=&nbsp;$.map&nbsp;$('#editor')[0].children,&nbsp;map</p><p class='code_line'>console.log&nbsp;'res:',&nbsp;res</p></div></div></code></div><p>&nbsp;</p><p><code class="inline_code">parse()</code> 函数没完. 其中很奇怪, 对 DOM 用 <code class="inline_code">map</code> 很奇怪</p><p><code class="inline_code">else</code> 那儿添加的 <code class="inline_code">[]</code>其实我很困惑, 按列表的操作那是不该有的呀</p><p>都是调试时候无奈写的代码, 不知道怎么改, 暂时是可以读出内容的</p><p>&nbsp;</p><p>按计划, 后面应该写自动补全提示了的, 可整天打不起精神</p><p>如果事成, 我把 js 部分打包成接口放在 gh-pages , 再到别的项目调用</p><p>比如写个代号 <code class="inline_code">feather</code> 的 Shell 的图形版, 用 Node 写系统脚本</p><p>设置扩展到向数据库存取 Cirru 生成的文本的功能, 为模块做准备</p><p>但最大的问题是怎样设计语言, 心里没底, 的确, 表达式解析是不够的</p><p>现在能做的只是生成 JS, 大家都做的, 但我手头学过的技能并不够</p><p>&nbsp;</p><p>而且最大的问题是我做怎样一门语言呢, 都已经缺失了各种文本工具了</p><p><code class="inline_code">import</code> 是最头疼的功能, 我打算是从数据库调用, 然后加到作用域里</p><p>还有从网络上 import 的功能, hamony 版本记得是有说到的</p><p>但我设计的语言恐怕会和 JS 有不孝的差异, 直接用 JS 问题不会少</p><p>做不难, 只是持续前进的动力和光明在哪里?</p><p>&nbsp;</p>   <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'jiyinyiyong'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></div>   <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'jiyinyiyong'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>