<title>130826-events-inside-outside.md</title><meta charset='utf-8'><link rel='stylesheet' href='../src/page.css' /><link rel='stylesheet'  href='http://softwaremaniacs.org/media/soft/highlight/styles/github.css'><div class='home'><a href='../index.html '>Home</a></div><div class='article'><h1>输入和输出的事件</h1>
<p>第一次用 <a href="http://socket.io/">Socket.IO</a> 的 <code>.broadcast</code> 时惊讶消息没发送成功<br>好久才发现消息发送到服务器后并没有返回到本地的 socket, 文档写了的<br>只是为了省事, 加上刚会 jQuery 操作 DOM 做聊天, 就手动重新发送了一次<br>当时我没有觉得 Socket.IO 的方案有什么好处, 只是作为技术上的方案接受了<br>那是两年前了, 到今年实习才开始对付浏览器端模版的应用</p>
<p>Backbone 有 Model 有 View, 而 Controller 分散在 Router 和 View 里<br>而我大部分时间在对付 View 相关的代码, 开始明白状态上的麻烦<br>Model 和 View 之间数据同步在 Backbone 需要手动管理, 复杂且容易出 Bug<br>特别是前端应用为了交互, 通常避免大范围刷新, 于是 DOM 操作又大量引入<br>我还不熟练的一个方案是用 SubView 的局部刷新来避免 DOM 操作的状态问题</p>
<p>状态问题只能学新的方案了, 另一个问题显得更清晰一些, 事件出现循环</p>
<h3>Model 和 View 出现循环的事件</h3>
<p>Model 和 View 主要通过事件来同步, 而操作 Model 的方法经常写在 View 里<br>渐渐一个问题重复很多次, <strong>View 和 Model 之间会出现循环的事件触发</strong><br>因为我们的应用一方面数据自动保存, 一方面同时两个 View 出现在界面上<br>一边通过事件轮询捕获数据改变存入 Model, 一方面 Model 事件改变 View<br>这样就出现了死循环</p>
<p>我直观的想法是, 一个事件应该辨别消息是否是自身发出, 以区别对待<br>于是我尝试在 Backbone 事件传递加上调用源头的对象, 用来区别<br>两个 View 更新数据时问题解决了, 然而又出现了网络请求更新数据的场景<br>我只好给网络请求再考虑一个源头, 每次监听事件做相应的区分<br>总之不是个好的方案, 问题只是缓解而不是解决</p>
<h3>模块上的事件循环</h3>
<p>这几天写一个选择菜单, 遇到了类似的问题, 事件不区分来源带来问题<br><code>SelectMenu</code> 有 <code>select</code> 事件, 事件是两方面的<br>一是外部传入事件改变菜单选项, 一是菜单因为点击而改变, 触发事件<br>当然两者可以取不同的名字来规避, 只是同样的事件名称显得更自然<br>而我们不会混淆是因为我们可以从调用环境很轻松区分 <code>select</code> 指什么<br>在 JS 里, 方法调用被抽象得很简单, 对调用环境不会做区分</p>
<p>或者我们在外边用 <code>.trigger</code>, 在内部直接用方法调用, 也不会混淆<br>不过当时没想清楚, 就用 <code>on/emit bind/trigger</code> 不同的方法做区分了<br>使用了两个数组了区别地保存两类事件:</p>
<pre><code class="lang-coffee">fn = SelectMenu.<span class="keyword">prototype</span>

fn.emit = (eventName, data) -&gt;
  <span class="keyword">if</span> <span class="variable">@eventsOutside</span>[eventName]?
    <span class="variable">$.</span><span class="keyword">each</span> <span class="variable">@eventsOutside</span>[eventName], (<span class="keyword">index</span>, callback) =&gt;
      callback.call <span class="variable">@,</span> data

fn.on = (eventName, callback) -&gt;
  <span class="keyword">if</span> eventName? <span class="keyword">and</span> (typeof callback) is <span class="string">'function'</span>
    <span class="keyword">unless</span> callback in <span class="variable">@eventsOutside</span>[eventName]
      this.eventsOutside[eventName].<span class="keyword">push</span> callback

fn.trigger = (eventName, data) -&gt;
  <span class="keyword">if</span> <span class="variable">@eventsInside</span>[eventName]?
    <span class="variable">$.</span><span class="keyword">each</span> <span class="variable">@eventsInside</span>[eventName], (<span class="keyword">index</span>, callback) =&gt;
      callback.call self, data

fn.init = -&gt;
  <span class="variable">@eventsInside</span> = <span class="keyword">open</span>: [], <span class="keyword">close</span>: [], <span class="keyword">select</span>: []
  <span class="variable">@eventsOutside</span> = <span class="keyword">open</span>: [], <span class="keyword">close</span>: [], <span class="keyword">select</span>: []</code></pre>
<h3>分离出模块, 面向对象</h3>
<p>前些天看了个<a href="https://www.youtube.com/watch?v=Y7rq6o6UDXc">关于 Smalltalk 的视频</a>, 很早的时间介绍了 Smalltalk<br>里边讲的主要还是 OOP 这套编程思想的由来, 概念和现在我学的差不多<br>可以感受到, OOP 是为了维护大型 codebase 更方便而设计的<br>需求改变以后, 代码的改变尽可能少, 稳定性高, 开发效率提高<br>通过对象的继承和方法的覆写将大量的代码进行统一和重用<br>我越是学习, 越是感到 OOP 思想在 Web 应用开发的上带来的效率</p>
<p>我想开发效率是这个时代追求的, 无论图形编程, FP, OOP<br>OOP 我看来有点像将代码注入到作用域当中来实现代码重用<br>通过 <code>this</code> 共享作用域, 让不同的代码在同一作用域交互<br>也许我们有更灵活的方案能做更多</p>
</div><div id="disqus_thread"></div>
  <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'jiyinyiyong';
      // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script');
          dsq.type = 'text/javascript';
          dsq.async = true;
          dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
          if (document.getElementsByTagName('head')[0]) {
            document.getElementsByTagName('body')[0].appendChild(dsq);
          }
      })();
  </script>
  <noscript>
    Please enable JavaScript to view the
    <a href="http://disqus.com/?ref_noscript">
      comments powered by Disqus.
    </a>
  </noscript>
  <a href="http://disqus.com" class="dsq-brlink">
    comments powered by
    <span class="logo-disqus">
      Disqus
    </span>
  </a>
</div><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-41753901-1', 'jiyinyiyong.github.io');
  ga('send', 'pageview');
</script>