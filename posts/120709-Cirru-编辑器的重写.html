<title>Cirru 编辑器重写的感受</title><meta charset='utf-8'>  <div id='article'><a id='home' href='../index.html'>Home</a><link rel="stylesheet" href="../style.css"><pre> </pre><pre><pre class='title'>Cirru 编辑器重写的感受</pre></pre><pre> </pre><pre>回到家这几天, 大学好绝望, 而且从没能很专心学东西过, 所以代码很慢</pre><pre>只是写了下, 感受良多. 而且边写边搜 jQuery 的 API 感觉不错</pre><pre>之前 fork nodeclub 的界面时被其中几行 jQuery 打动了</pre><pre>比如用 <code class="inline_code">.parent()</code> 用 <code class="inline_code">.find()</code> 在 DOM 里徘徊都是之前我没接触过的</pre><pre><a href="https://github.com/jiyinyiyong/nodeclub/blob/master/views/topic/index.html#L195">github.com/jiyinyiyong/nodeclub/blob/master/views/topic/index.html#L195</a></pre><pre> </pre><pre class='code_block'><pre>var editor = $btn.parents('.reply2_area').find('.reply2_editor');</pre><pre>editor.show('fast');</pre><pre>editor.find('textarea').focus();</pre><pre>var user = $btn.parents('.reply2_item').find('.reply_author').find('a').html();</pre><pre>var textarea = editor.find('textarea');</pre></code></pre><pre> </pre><pre>我所有的知识来源无非论坛, 新闻和搜索, 遇事也只好自己对付</pre><pre>那么摸索了最后自己能抱一个什么样的目标呢? 我一再一再惶惑</pre><pre>Cirru 是插曲, 本想设计很先进的聊天室等人去实现的, 可聊天室没动静</pre><pre>Cirru 只想未来能成就语言, 算我在赌一个未来, 人们接受自动管理括号么?</pre><pre>上一次尝试, 两个月前, 做得比较多, 详细的想法当时有记录:</pre><pre><a href="https://github.com/jiyinyiyong/code_blocks/blob/gh-pages/about.md">github.com/jiyinyiyong/code_blocks/blob/gh-pages/about.md</a></pre><pre> </pre><pre>关于代码, 主要是设置当前元素 <code class="inline_code">contenteditable = true</code> 来提供编辑能力</pre><pre>然后用 jQUery 不断调换 <code class="inline_code">editable</code> 绑定元素, 比如在响应事件时</pre><pre>嵌套关系映射在这里其实是 DOM 里的嵌套, 最后的 <code class="inline_code">parse()</code> 也是这么想的</pre><pre> </pre><pre class='code_block'><pre>$ -&gt;</pre><div class='code_block'><pre>editable = 'contenteditable'</pre><pre>caret = "&ltcode id='target' #{editable}='true'/&gt;"</pre><pre>blank = ['', '&ltbr&gt;']</pre><pre>paste = ''</pre></div></code></pre><pre> </pre><pre>正在编辑的元素标记名称为 <code class="inline_code">#point</code>, 另外 <code class="inline_code">#target</code> 和上面的 <code class="inline_code">caret</code> 对应</pre><pre>我重写的方案是在移动 <code class="inline_code">#point</code> 时不先移动, 而是先绘制一个 <code class="inline_code">#target</code> 作为目标</pre><pre>再调用 <code class="inline_code">point()</code> 将完成这一步转化</pre><pre> </pre><pre class='code_block'><div class='code_block'><pre>p = -&gt; $ '#point'</pre><pre>t = -&gt; $ '#target'</pre><pre> </pre><pre>empty = (elem) -&gt; elem.html() in blank</pre><pre>root = (elem) -&gt; elem.parent().attr('id') is 'editor'</pre><pre>exist = (elem) -&gt; elem.length &gt; 0</pre><pre>leaf = (elem) -&gt; elem[0].tagName is 'CODE'</pre></div></code></pre><pre> </pre><pre>上面四个函数用来判断节点具体的位置, 具体用到时逻辑比较繁琐</pre><pre><code class="inline_code">point()</code> 接收的参数只是为屏蔽 <code class="inline_code">click</code> 一次多余的 <code class="inline_code">focus()</code>, 意义不大</pre><pre>函数目标是将 <code class="inline_code">#point</code> 取消标记, 如果为空, 还要递归地将空元素删除</pre><pre>不过 <code class="inline_code">#point</code> 在 <code class="inline_code">delete</code> 时会强制删除, 因而可能元素已经不存在了</pre><pre> </pre><pre class='code_block'><div class='code_block'><pre>point = (refocus = yes) -&gt;</pre><div class='code_block'><pre>old = p().removeAttr('id').removeAttr editable</pre><pre>if exist old</pre><div class='code_block'><pre>old.html (old.html().replace /\&ltbr\&gt;/g, '')</pre><pre>old[0].onclick = (e) -&gt;</pre><div class='code_block'><pre>old.attr('id', 'target').attr(editable, 'true')</pre><pre>point off</pre><pre>e.stopPropagation()</pre></div><pre>while empty old</pre><div class='code_block'><pre>up = old.parent()</pre><pre>old.remove()</pre><pre>old = up</pre><pre>if root old</pre><div class='code_block'><pre>if empty old then old.remove()</pre><pre>break</pre></div></div></div><pre>t().attr('id', 'point').attr(editable, 'true')</pre><pre>if refocus then focus()</pre></div></div></code></pre><pre> </pre><pre>聚焦主要是处理怎样将光标放在字串结尾, 代码是搜索抄的, 不清晰</pre><pre>当时写着一遍测试 <code class="inline_code">collapse()</code> 不同参数的效果, 很不安全的代码</pre><pre>StackOverflow 的代码解释不够清晰, 没看懂只能带过了</pre><pre><code class="inline_code">.inline</code> 是为了将单层的括号放在行内, 本想用 css 选择器, 最后换 jQuery</pre><pre> </pre><pre class='code_block'><div class='code_block'><pre>focus = -&gt;</pre><div class='code_block'><pre>sel = window.getSelection()</pre><pre>sel.collapse p()[0], 1</pre><pre>$('div').addClass 'inline'</pre><pre>$('div:has(div)').removeClass 'inline'</pre><pre>p().focus()</pre></div></div></code></pre><pre> </pre><pre>初始化最初的光标, 并指定 <code class="inline_code">click</code> 能将光标聚焦</pre><pre><code class="inline_code">in_sight</code> 是光标是否聚焦的状态, 打算包装成 lib, 可能用到</pre><pre> </pre><pre class='code_block'><div class='code_block'><pre>$('#editor').append caret</pre><pre>t().attr 'id', 'point'</pre><pre>focus()</pre><pre>$('#editor')[0].onclick = (e) -&gt;</pre><div class='code_block'><pre>focus()</pre><pre>e.stopPropagation()</pre><pre>parse()</pre></div><pre> </pre><pre>in_sight = yes</pre><pre>$('#editor').bind 'focus', -&gt; in_sight = yes</pre><pre>$('#editor').bind 'blur', -&gt; in_sight = no</pre><pre> </pre><pre>$('#editor').keydown (e) -&gt;</pre><div class='code_block'><pre># console.log e.keyCode</pre><pre>if in_sight</pre><div class='code_block'><pre>switch e.keyCode</pre></div></div></div></code></pre><pre> </pre><pre>回车键创建嵌套, 跳出当前 <code class="inline_code">#point</code> 在后嵌入 <code class="inline_code">#target</code> 而已</pre><pre>Tab 就直接谁知 <code class="inline_code">#target</code> 就好了</pre><pre> </pre><pre class='code_block'><div class='code_block'><div class='code_block'><div class='code_block'><div class='code_block'><pre>when 13</pre><div class='code_block'><pre>p().after "&ltdiv&gt;#{caret}&lt/div&gt;"</pre><pre>next = p().next()</pre><pre>next[0].onclick = (e) -&gt;</pre><div class='code_block'><pre>next.append caret</pre><pre>point()</pre><pre>e.stopPropagation()</pre></div></div><pre>when 9 then p().after caret</pre></div></div></div></div></code></pre><pre> </pre><pre>删除时默认落到前一个字串去, 没有前就往后, 再没有就尝试删除嵌套</pre><pre>当然向前向后遇到嵌套的话要进入到嵌套当中去</pre><pre> </pre><pre class='code_block'><div class='code_block'><div class='code_block'><div class='code_block'><div class='code_block'><pre>when 46 # key delete</pre><div class='code_block'><pre>if exist p().prev()</pre><div class='code_block'><pre>it = p().prev()</pre><pre>if leaf it then it.attr 'id', 'target'</pre><pre>else it.append caret</pre></div><pre>else if exist p().next()</pre><div class='code_block'><pre>it = p().next()</pre><pre>if leaf it then it.attr 'id', 'target'</pre><pre>else it.prepend caret</pre></div><pre>else unless root p()</pre><div class='code_block'><pre>p().parent().after(caret).remove()</pre></div><pre>else unless p().html() in blank then p().after caret</pre><pre>else return on</pre><pre>p().remove()</pre></div></div></div></div></div></code></pre><pre> </pre><pre>上下键按字串跳, 遇到嵌套也会自动进入/退出</pre><pre> </pre><pre class='code_block'><div class='code_block'><div class='code_block'><div class='code_block'><div class='code_block'><pre>when 38 # up</pre><div class='code_block'><pre>unless p().html() in blank then p().before caret</pre><pre>else if exist p().prev()</pre><div class='code_block'><pre>prev = p().prev()</pre><pre>if leaf prev then prev.attr 'id', 'target'</pre><pre>else prev.append caret</pre></div><pre>else unless root p() then p().parent().before caret</pre><pre>else return off</pre></div><pre>when 40 # down</pre><div class='code_block'><pre>unless p().html() in blank then p().after caret</pre><pre>else if exist p().next()</pre><div class='code_block'><pre>next = p().next()</pre><pre>if leaf next then next.attr 'id', 'target'</pre><pre>else next.prepend caret</pre></div><pre>else unless root p() then p().parent().after caret</pre><pre>else return off</pre></div></div></div></div></div></code></pre><pre> </pre><pre>剪切粘贴的实现比较粗糙, 快捷键绑定在 Chrome 里没多少键可指定</pre><pre>幸而有 <code class="inline_code">.outerHTML</code> 这个属性, 否则实现起来更麻烦了</pre><pre> </pre><pre class='code_block'><div class='code_block'><div class='code_block'><div class='code_block'><div class='code_block'><pre>when 219 # ctrl + [</pre><div class='code_block'><pre>if e.ctrlKey and (not (root p()))</pre><div class='code_block'><pre>up = p().parent()</pre><pre>up.after caret</pre><pre>point()</pre><pre>console.log up.parent()</pre><pre>paste = up[0].innerHTML or ''</pre><pre>up.remove()</pre></div><pre>return on</pre></div><pre>when 221 # ctrl + ]</pre><div class='code_block'><pre>if e.ctrlKey and paste.length &gt; 0</pre><div class='code_block'><pre>p().before paste</pre></div><pre>return on</pre></div><pre>when 33 # pgup</pre><div class='code_block'><pre>unless root p() then p().parent().before caret</pre><pre>else return on</pre></div><pre>when 34 # pgdown</pre><div class='code_block'><pre>unless root p() then p().parent().after caret</pre><pre>else return on</pre></div><pre>else return on</pre></div><pre>point()</pre></div><pre>e.stopPropagation()</pre><pre>off</pre></div></div></code></pre><pre> </pre><pre>为了阻止键盘事件副作用, 上面有比较多的 <code class="inline_code">return</code> 来处理逻辑</pre><pre><code class="inline_code">.stopPropagation()</code> 方法是 <code class="inline_code">click</code> 用的, 这边没必要</pre><pre>不过此前尝试多种尝试组织冒泡都没成功, 这个方法是很随意的了</pre><pre> </pre><pre class='code_block'><div class='code_block'><pre>parse = -&gt;</pre><div class='code_block'><pre>map = (item, b) -&gt;</pre><div class='code_block'><pre>if leaf [item] then item.innerText</pre><pre>else [$.map item.children, (x) -&gt; map x]</pre></div><pre>res = $.map $('#editor')[0].children, map</pre><pre>console.log 'res:', res</pre></div></div></code></pre><pre> </pre><pre><code class="inline_code">parse()</code> 函数没完. 其中很奇怪, 对 DOM 用 <code class="inline_code">map</code> 很奇怪</pre><pre><code class="inline_code">else</code> 那儿添加的 <code class="inline_code">[]</code>其实我很困惑, 按列表的操作那是不该有的呀</pre><pre>都是调试时候无奈写的代码, 不知道怎么改, 暂时是可以读出内容的</pre><pre> </pre><pre>按计划, 后面应该写自动补全提示了的, 可整天打不起精神</pre><pre>如果事成, 我把 js 部分打包成接口放在 gh-pages , 再到别的项目调用</pre><pre>比如写个代号 <code class="inline_code">feather</code> 的 Shell 的图形版, 用 Node 写系统脚本</pre><pre>设置扩展到向数据库存取 Cirru 生成的文本的功能, 为模块做准备</pre><pre>但最大的问题是怎样设计语言, 心里没底, 的确, 表达式解析是不够的</pre><pre>现在能做的只是生成 JS, 大家都做的, 但我手头学过的技能并不够</pre><pre> </pre><pre>而且最大的问题是我做怎样一门语言呢, 都已经缺失了各种文本工具了</pre><pre><code class="inline_code">import</code> 是最头疼的功能, 我打算是从数据库调用, 然后加到作用域里</pre><pre>还有从网络上 import 的功能, hamony 版本记得是有说到的</pre><pre>但我设计的语言恐怕会和 JS 有不孝的差异, 直接用 JS 问题不会少</pre><pre>做不难, 只是持续前进的动力和光明在哪里?</pre><pre> </pre><div id="disqus_thread"></div>
  <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'jiyinyiyong';
      // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script');
          dsq.type = 'text/javascript';
          dsq.async = true;
          dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
          if (document.getElementsByTagName('head')[0]) {
            document.getElementsByTagName('body')[0].appendChild(dsq);
          }
      })();
  </script>
  <noscript>
    Please enable JavaScript to view the
    <a href="http://disqus.com/?ref_noscript">
      comments powered by Disqus.
    </a>
  </noscript>
  <a href="http://disqus.com" class="dsq-brlink">
    comments powered by
    <span class="logo-disqus">
      Disqus
    </span>
  </a>
</div></div>